<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Coconut Circuit — 3rd-Person Kart (Full)</title>
<style>
  html,body{height:100%;margin:0;background:#cfeefd;display:flex;align-items:center;justify-content:center;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  .container{width:1150px;max-width:98vw;background:#fff;border-radius:12px;box-shadow:0 12px 40px rgba(2,6,23,0.18);overflow:hidden}
  header{display:flex;align-items:center;justify-content:space-between;padding:14px 18px;border-bottom:1px solid #eee}
  header h1{margin:0;font-size:18px}
  .content{display:grid;grid-template-columns:1fr 360px;gap:14px;padding:14px}
  #game{width:100%;height:700px;background:linear-gradient(#f7eacb,#ffe);display:block;border-radius:8px}
  .panel{background:linear-gradient(180deg,#fff,#fafafa);padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(2,6,23,0.03)}
  .stat{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,monospace}
  button{padding:8px 12px;border-radius:8px;border:0;background:#0ea5e9;color:#fff;cursor:pointer}
  .small{font-size:13px;color:#475569}
  .muted{color:#9aa4b2}
  footer{padding:10px 14px;border-top:1px solid #eee;font-size:13px}
  .row{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
  .miniturboBar{height:14px;border-radius:8px;background:#1111;overflow:hidden}
  .mtFill{height:100%;width:0%;background:linear-gradient(90deg,#3ab7ff,#ffb86b);transition:width 80ms linear}
  .mtLabel{font-weight:700;font-size:13px;margin-top:6px}
  .itemBox{width:42px;height:28px;border-radius:6px;background:linear-gradient(180deg,#fff,#eee);display:flex;align-items:center;justify-content:center;border:2px solid #c9b27a}
</style>
</head>
<body>
  <div class="container" id="app">
    <header>
      <h1>Coconut Circuit — 3rd-Person Kart (Full)</h1>
      <div class="small muted">WASD / Arrows • Space drift • E trick • X glider • Q use item</div>
    </header>

    <div class="content">
      <div>
        <canvas id="game" width="1150" height="700"></canvas>
        <div style="display:flex;gap:8px;margin-top:10px">
          <button id="startBtn">Start Run</button>
          <button id="resetBtn" style="background:#f97316">Reset Position</button>
          <button id="clearBest" style="background:#6b7280">Clear Best</button>
        </div>
      </div>

      <aside style="display:flex;flex-direction:column;gap:10px">
        <div class="panel">
          <div class="row"><div class="small">Driver</div><div class="stat">Mario</div></div>
          <div class="row"><div class="small">Laps</div><div class="stat" id="lapCounter">0 / 3</div></div>
          <div class="row"><div class="small">Current Lap</div><div class="stat" id="curLapTime">00:00.000</div></div>
          <div class="row"><div class="small">Total Time</div><div class="stat" id="totalTime">00:00.000</div></div>
          <div class="row"><div class="small">Best (local)</div><div class="stat" id="bestTime">--:--.---</div></div>

          <div style="height:1px;background:#eee;margin:10px 0"></div>

          <div class="small">Mini-Turbo</div>
          <div class="miniturboBar"><div id="mtFill" class="mtFill"></div></div>
          <div class="mtLabel" id="mtLabel">No Charge</div>

          <div style="height:6px"></div>
          <div class="small">Item</div>
          <div style="display:flex;gap:8px;align-items:center">
            <div class="itemBox" id="itemBox">—</div>
            <div class="small muted">Press Q to use</div>
          </div>

          <div style="height:8px"></div>
          <div class="small">Tips</div>
          <ul style="margin:6px 0 0 18px;padding:0" class="muted">
            <li>Hold Space to drift. Release to get a mini-turbo — blue/orange/purple (longer & stronger).</li>
            <li>Jump ramps let you perform tricks (press E). Land cleanly to get trick boost.</li>
            <li>Glider (X) can be deployed when high enough after a big ramp; it gives air control and soft landing.</li>
            <li>Use items (Q) to hinder AI or get bursts.</li>
          </ul>
        </div>

        <div class="panel small">
          <div style="font-weight:600;margin-bottom:6px">Track / Gameplay</div>
          <div class="muted">3rd-person behind-camera, boost panels, jump ramps, items, trick boosts, glider, and AI racers included.</div>
        </div>
      </aside>
    </div>

    <footer>
      <div class="small muted">Standalone. If something breaks, tell me the browser console error and I'll patch it. Want sound next?</div>
    </footer>
  </div>

<script>
(() => {
  // -----------------------
  // CONFIG (tweak here)
  // -----------------------
  const CONFIG = {
    canvasW: 1150, canvasH: 700,
    laps: 3,
    car: {
      mass: 120,           // for more realistic acceleration forces
      maxSpeed: 520,      // px/sec
      accelForce: 2200,   // force units -> acceleration = force / mass
      brakeForce: 4200,
      reverseMax: -160,
      baseTurnDeg: 160,   // degrees/sec max baseline (converted later)
      grip: 10.0,         // lateral grip coefficient
      driftGrip: 2.0,     // grip while drifting (lower means slide more)
      driftChargeRate: 1.15, // units/sec charging
      miniTurboLevels: 3,
      // per-level: multiplier and duration (seconds)
      miniTurbo: [
        { color: '#3ab7ff', label: 'Blue', multiplier: 1.12, duration: 0.8 },    // short
        { color: '#ffb86b', label: 'Orange', multiplier: 1.22, duration: 1.1 },  // medium
        { color: '#b197ff', label: 'Purple', multiplier: 1.38, duration: 1.4 }   // long
      ],
      trickBoostMult: 1.18,
      gliderDrag: 0.994,
      jumpMinSpeed: 240,    // speed to be able to get glider after big ramp
    },
    boostPad: { power: 260, length: 64 }, // power is extra speed added instantly
    ramp: { indexRatio: 0.58, impulseBase: 360, minGliderHeight: 48 }, // ramp position and impulse
    physics: { gravity: 900 },
    aiCount: 3,
    itemBoxes: { indicesRatio: [0.13, 0.36, 0.74], spawnRadius: 28 },
    randomSeed: 42
  };

  // -----------------------
  // Utils
  // -----------------------
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function now(){ return performance.now(); }
  function rand(n=1){ return Math.random()*n; }
  // format seconds to mm:ss.mmm
  function fmtTime(sec){ if(!sec) sec = 0; const m = Math.floor(sec/60); const s = sec - m*60; return `${String(m).padStart(2,'0')}:${s.toFixed(3).padStart(6,'0')}`; }

  // -----------------------
  // Canvas + UI
  // -----------------------
  const canvas = document.getElementById('game');
  canvas.width = CONFIG.canvasW;
  canvas.height = CONFIG.canvasH;
  const ctx = canvas.getContext('2d');

  const lapCounterEl = document.getElementById('lapCounter');
  const curLapTimeEl = document.getElementById('curLapTime');
  const totalTimeEl = document.getElementById('totalTime');
  const bestTimeEl = document.getElementById('bestTime');
  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');
  const clearBestBtn = document.getElementById('clearBest');
  const mtFill = document.getElementById('mtFill');
  const mtLabel = document.getElementById('mtLabel');
  const itemBoxEl = document.getElementById('itemBox');

  // -----------------------
  // Track generation (spline centerline -> rails)
  // -----------------------
  const centerX = canvas.width/2, centerY = canvas.height/2;
  const ctrl = [
    {x: centerX + 420, y: centerY, type:'normal'},
    {x: centerX + 260, y: centerY - 190, type:'normal'},
    {x: centerX + 40,  y: centerY - 270, type:'normal'},
    {x: centerX - 250, y: centerY - 150, type:'normal'},
    {x: centerX - 360, y: centerY + 30,  type:'normal'},
    {x: centerX - 220, y: centerY + 250, type:'ramp'},
    {x: centerX - 20,  y: centerY + 300, type:'normal'},
    {x: centerX + 160, y: centerY + 240, type:'boost'},
    {x: centerX + 330, y: centerY + 90,  type:'normal'},
  ];

  // Catmull-Rom
  function catmullRom(p0,p1,p2,p3,t){
    const t2 = t*t, t3 = t2*t;
    return {
      x: 0.5 * ( (2*p1.x) + (-p0.x + p2.x)*t + (2*p0.x - 5*p1.x + 4*p2.x - p3.x)*t2 + (-p0.x + 3*p1.x - 3*p2.x + p3.x)*t3 ),
      y: 0.5 * ( (2*p1.y) + (-p0.y + p2.y)*t + (2*p0.y - 5*p1.y + 4*p2.y - p3.y)*t2 + (-p0.y + 3*p1.y - 3*p2.y + p3.y)*t3 )
    };
  }

  const centerline = [];
  const samplesPerSegment = 48;
  for(let i=0;i<ctrl.length;i++){
    const p0 = ctrl[(i-1+ctrl.length)%ctrl.length];
    const p1 = ctrl[i];
    const p2 = ctrl[(i+1)%ctrl.length];
    const p3 = ctrl[(i+2)%ctrl.length];
    for(let s=0;s<samplesPerSegment;s++){
      const t = s / samplesPerSegment;
      centerline.push(catmullRom(p0,p1,p2,p3,t));
    }
  }

  // rails, normals
  const track = [];
  const baseWidth = 140;
  for(let i=0;i<centerline.length;i++){
    const a = centerline[i];
    const b = centerline[(i+1)%centerline.length];
    const dx = b.x - a.x, dy = b.y - a.y;
    const len = Math.hypot(dx,dy) || 1;
    const nx = -dy/len, ny = dx/len;
    const width = baseWidth * (1 + 0.12*Math.sin(i*0.06));
    track.push({
      cx: a.x, cy: a.y, nx, ny,
      leftX: a.x + nx*(width/2), leftY: a.y + ny*(width/2),
      rightX: a.x - nx*(width/2), rightY: a.y - ny*(width/2),
      width
    });
  }

  const sfIndex = 0;
  const boostPads = CONFIG.itemBoxes.indicesRatio.map(r => ({ index: Math.floor(centerline.length * r), used: false }));
  const rampIndex = Math.floor(centerline.length * CONFIG.ramp.indexRatio);
  const shortcut = { entry: Math.floor(centerline.length * 0.92), exit: Math.floor(centerline.length * 0.06) };

  // item boxes (placed at certain indices)
  const itemBoxes = CONFIG.itemBoxes.indicesRatio.map(r => ({ index: Math.floor(centerline.length * r), taken: false }));

  // -----------------------
  // Player & AI
  // -----------------------
  const player = {
    index: sfIndex + 1, // floating index along centerline
    lateral: 0,         // -1..1 (left..right)
    speed: 0,
    angle: 0,
    altitude: 0,
    yVel: 0,
    onGround: true,
    drifting: false,
    driftCharge: 0,
    driftDir: 0,
    hasItem: null,
    glider: false,
    trickActive: false,
    lastBoostEnd: 0
  };

  // small AI racers: they follow the centerline index and try to maintain target speed
  const ais = [];
  for(let i=0;i<CONFIG.aiCount;i++){
    ais.push({
      index: sfIndex + 1 - (i+1) * (centerline.length * 0.06),
      lateral: (i % 2 === 0 ? -0.2 : 0.2),
      speed: CONFIG.car.maxSpeed * 0.72,
      color: i===0 ? '#ffd166' : i===1 ? '#6ee7b7' : '#a78bfa',
      aiState: {}
    });
  }

  // load best
  let bestRecord = null;
  try{ bestRecord = JSON.parse(localStorage.getItem('coconut_best_3p_v2')); }catch(e){ bestRecord = null; }
  if(bestRecord) bestTimeEl.textContent = fmtTime(bestRecord.total);

  // -----------------------
  // Input
  // -----------------------
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if(['arrowup','arrowdown','arrowleft','arrowright'].includes(e.key.toLowerCase())) e.preventDefault();
  });
  window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

  // -----------------------
  // Particles & small helpers
  // -----------------------
  const particles = [];
  function spawnParticle(x,y,vx,vy,life,color,size=3){ particles.push({x,y,vx,vy,life,age:0,color,size}); }
  function updateParticles(dt){
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.age += dt;
      if(p.age >= p.life) particles.splice(i,1);
      else { p.x += p.vx * dt; p.y += p.vy * dt; }
    }
  }

  // -----------------------
  // Camera: third-person behind-the-car
  // We'll use a transform: translate to screen center, then rotate world opposite to player.angle,
  // then draw world so the camera sits behind the car. This gives a true behind-the-car feel.
  // -----------------------
  const camera = { x:0, y:0, zoom:1 };
  function worldToScreen(wx, wy, alt=0){
    // Apply camera transform (after we've already applied ctx transform in render)
    // Here we'll compute screen coords manually for elements needing absolute positioning (HUD/particles)
    const sx = (canvas.width/2) + (wx - camera.x) * camera.zoom;
    const sy = (canvas.height/2) + (wy - camera.y) * camera.zoom - alt * camera.zoom * 0.35;
    return { x: sx, y: sy };
  }

  // -----------------------
  // Racing state
  // -----------------------
  let runActive = false;
  let lapStartTime = 0;
  let lapTimes = [];

  // -----------------------
  // Physics helpers: get centerline sample / tangent length
  // -----------------------
  function wrapIndex(idx){
    const L = centerline.length;
    while(idx < 0) idx += L;
    return idx % L;
  }
  function getCenterFloat(idx){
    const L = centerline.length;
    // handle negative
    const wrapped = (idx % L + L) % L;
    const i = Math.floor(wrapped);
    const t = wrapped - i;
    const a = centerline[i];
    const b = centerline[(i+1)%L];
    return { x: lerp(a.x, b.x, t), y: lerp(a.y, b.y, t), i, t };
  }
  function tangentLengthAt(idx){
    const a = getCenterFloat(idx);
    const b = getCenterFloat(idx + 1);
    return Math.hypot(b.x - a.x, b.y - a.y) || 1;
  }
  function playerWorldPos(){
    const L = track.length;
    const idx = wrapIndex(player.index);
    const i = Math.floor(idx);
    const t = idx - i;
    const a = track[i], b = track[(i+1)%L];
    const cx = lerp(a.cx, b.cx, t);
    const cy = lerp(a.cy, b.cy, t);
    const nx = lerp(a.nx, b.nx, t);
    const ny = lerp(a.ny, b.ny, t);
    const width = lerp(a.width, b.width, t);
    const lateralPx = player.lateral * (width/2 - 12);
    return { x: cx + nx * lateralPx, y: cy + ny * lateralPx, nx, ny, width };
  }

  function aiWorldPos(ai){
    const L = track.length;
    const idx = wrapIndex(ai.index);
    const i = Math.floor(idx);
    const t = idx - i;
    const a = track[i], b = track[(i+1)%L];
    const cx = lerp(a.cx, b.cx, t);
    const cy = lerp(a.cy, b.cy, t);
    const nx = lerp(a.nx, b.nx, t);
    const ny = lerp(a.ny, b.ny, t);
    const width = lerp(a.width, b.width, t);
    const lateralPx = ai.lateral * (width/2 - 12);
    return { x: cx + nx * lateralPx, y: cy + ny * lateralPx };
  }

  // -----------------------
  // Item system
  // -----------------------
  const ITEM_POOL = ['banana','mushroom','boostBox','shell']; // simple pool
  function giveRandomItem(target){
    const it = ITEM_POOL[Math.floor(rand(ITEM_POOL.length))];
    target.hasItem = it;
    if(target === player) itemBoxEl.textContent = it[0].toUpperCase();
  }

  // use item
  function usePlayerItem(){
    if(!player.hasItem) return;
    const it = player.hasItem;
    player.hasItem = null;
    itemBoxEl.textContent = '—';
    if(it === 'banana'){
      // drop banana at player's position: mark an obstacle on track (simple array)
      droppedBananas.push({ x: playerWorldPos().x, y: playerWorldPos().y, radius: 14, life: 14 });
      flashMsg('Banana! (dropped)', '#fbbf24', 800);
    } else if(it === 'mushroom'){
      // turbo burst
      player.speed = Math.min(player.speed + 320, CONFIG.car.maxSpeed * 1.6);
      flashMsg('Mushroom! Turbo', '#ffb86b', 900);
    } else if(it === 'boostBox'){
      // give everyone a small boost (including player)
      player.speed = Math.min(player.speed + 220, CONFIG.car.maxSpeed * 1.6);
      ais.forEach(a=> a.speed = Math.min(a.speed + 160, CONFIG.car.maxSpeed * 1.3));
      flashMsg('Speed field!', '#8be9ff', 800);
    } else if(it === 'shell'){
      // target the nearest AI in front and slow them
      let target = null, bestd = Infinity;
      const ppos = playerWorldPos();
      for(const a of ais){
        const apos = aiWorldPos(a);
        // only consider those ahead along track (index difference positive small)
        const d = Math.hypot(apos.x - ppos.x, apos.y - ppos.y);
        if(d < bestd){ bestd = d; target = a; }
      }
      if(target){
        target.speed = Math.max(80, target.speed - 220);
        flashMsg('Shell hit an AI!', '#ef4444', 800);
      } else flashMsg('No target', '#9aa4b2', 600);
    }
  }

  const droppedBananas = [];

  // -----------------------
  // MiniTurbo visuals & logic
  // -----------------------
  let mtState = { charge: 0, level: 0, activeUntil: 0 };

  // -----------------------
  // Flash message
  // -----------------------
  function flashMsg(msg,color='#111', duration=700){
    const el = document.createElement('div');
    el.textContent = msg;
    el.style.position = 'fixed';
    el.style.left = '50%';
    el.style.top = '28px';
    el.style.transform = 'translateX(-50%)';
    el.style.padding = '8px 14px';
    el.style.borderRadius = '8px';
    el.style.background = color;
    el.style.color = '#fff';
    el.style.zIndex = 9999;
    document.body.appendChild(el);
    setTimeout(()=>{ el.style.transition = 'all 300ms ease'; el.style.opacity = '0'; el.style.transform = 'translateX(-50%) translateY(-8px)'; }, duration);
    setTimeout(()=>el.remove(), duration + 350);
  }

  // -----------------------
  // Main update loop
  // -----------------------
  let lastTs = 0;
  function update(ts){
    if(!lastTs) lastTs = ts;
    const dt = Math.min(0.04, (ts - lastTs) / 1000);
    lastTs = ts;

    // INPUT
    const forward = keys['w'] || keys['arrowup'] || false;
    const back = keys['s'] || keys['arrowdown'] || false;
    const left = keys['a'] || keys['arrowleft'] || false;
    const right = keys['d'] || keys['arrowright'] || false;
    const driftKey = keys[' '] || false;
    const trickKey = keys['e'] || false;
    const gliderKey = keys['x'] || false;
    const itemKey = keys['q'] || false;

    // Use item (edge detect)
    if(itemKey && !prevKeys.q){ usePlayerItem(); }
    prevKeys.q = !!itemKey;

    // DRIFT logic: charge while holding space and turning
    if(driftKey && Math.abs(player.speed) > 40 && (left || right)){
      if(!player.drifting){
        player.drifting = true;
        player.driftDir = left ? -1 : 1;
      }
      player.driftCharge = Math.min(player.driftCharge + CONFIG.car.driftChargeRate * dt, CONFIG.car.miniTurboLevels * 1.6);
      // spawn drift sparks
      const p = playerWorldPos();
      for(let i=0;i<3;i++){
        spawnParticle(p.x + (Math.random()-0.5)*8, p.y + (Math.random()-0.5)*6, (Math.random()-0.5)*40 * dt, (Math.random()-0.5)*40 * dt, 0.6, 'rgba(255,200,80,0.9)', 2);
      }
    } else {
      // on release we compute level and apply boost
      if(player.drifting && player.driftCharge > 0){
        // map charge to levels (0 = none)
        const charge = player.driftCharge;
        let level = 0;
        if(charge >= 2.2) level = 3;
        else if(charge >= 1.2) level = 2;
        else if(charge >= 0.5) level = 1;
        if(level > 0){
          const mt = CONFIG.car.miniTurbo[level-1];
          player.speed = Math.min(player.speed * mt.multiplier, CONFIG.car.maxSpeed * 1.8);
          mtState.activeUntil = now() + mt.duration*1000;
          mtState.level = level;
          flashMsg(`${mt.label} Mini-Turbo!`, mt.color, 900);
        }
      }
      // reset drift state
      player.drifting = false;
      player.driftCharge = 0;
    }

    // update mt visual
    mtState.charge = player.driftCharge;
    updateMTUI();

    // ACCEL/BRK via simple force model: acceleration = force / mass
    let force = 0;
    if(forward) force += CONFIG.car.accelForce;
    if(back) force -= CONFIG.car.brakeForce;
    // convert force to acceleration
    const accel = force / CONFIG.car.mass;
    player.speed += accel * dt;
    // natural drag
    // heavier drag when on ground turning sharply; less drag in air
    const drag = player.onGround ? 0.995 : 0.999;
    player.speed *= drag;
    // clamp
    player.speed = clamp(player.speed, CONFIG.car.reverseMax, CONFIG.car.maxSpeed * 1.8);

    // turning: more realistic: curvature reduces with speed and grip; if drifting, reduced grip increases slide
    const speedRatio = clamp(Math.abs(player.speed) / CONFIG.car.maxSpeed, 0, 1);
    const baseTurn = (CONFIG.car.baseTurnDeg * Math.PI/180) * (1 - speedRatio*0.6); // rad/sec
    // when drifting, add extra steer but also reduce lateral grip
    const effectiveGrip = player.drifting ? CONFIG.car.driftGrip : CONFIG.car.grip;
    // apply angular change by projecting lateral input into heading change using speed and grip
    const steerInput = (left ? -1 : 0) + (right ? 1 : 0);
    // simple turning: angular acceleration scaled by steerInput, baseTurn, and sign of speed
    player.angle += baseTurn * steerInput * dt * (player.speed >= 0 ? 1 : -1) * (player.drifting ? 1.4 : 1.0);

    // Advance along centerline using speed and tangent length
    const tLen = tangentLengthAt(player.index);
    const idxDelta = (player.speed * dt) / tLen;
    const prevIndex = player.index;
    player.index = wrapIndex(player.index + idxDelta);

    // lateral adjustment: sliding dynamics
    const desiredLateral = player.drifting ? player.driftDir * 0.9 : (steerInput * 0.35);
    player.lateral = lerp(player.lateral, desiredLateral, clamp(3 * dt,0,1));

    // Jump ramp crossing detection
    const crossedRamp = crossesIndex(prevIndex, player.index, rampIndex);
    if(crossedRamp && player.onGround && player.speed > 140){
      // impulse upward proportional to speed
      player.yVel = CONFIG.ramp.impulseBase * (player.speed / CONFIG.car.maxSpeed);
      player.onGround = false;
      player.altitude = 2;
      player.glider = false;
      flashMsg('Jump!', '#8be9ff', 600);
    }

    // Vertical dynamics if airborne
    if(!player.onGround){
      player.yVel -= CONFIG.physics.gravity * dt;
      player.altitude += player.yVel * dt;
      // slight forward deceleration in air
      player.speed *= player.glider ? CONFIG.car.gliderDrag : 0.999;
      // trick detection
      if(trickKey && !player.trickActive && Math.abs(player.yVel) > 40){
        player.trickActive = true;
        flashMsg('Trick!', '#ff7ab6', 600);
      }
      // glider deploy
      if(gliderKey && !player.glider && player.altitude > CONFIG.ramp.minGliderHeight && player.yVel < -60){
        player.glider = true;
        flashMsg('Glider deployed', '#7dd3fc', 900);
      }
      // land
      if(player.altitude <= 0){
        player.altitude = 0;
        player.yVel = 0;
        player.onGround = true;
        if(player.trickActive){
          // successful trick -> boost and small camera shake
          player.speed = Math.min(player.speed * CONFIG.car.trickBoostMult, CONFIG.car.maxSpeed * 1.8);
          flashMsg('Trick Boost!', '#ffd166', 900);
          player.trickActive = false;
        }
        player.glider = false;
      }
    }

    // Apply boost pad detection (player prox to any boost pad center)
    for(const pad of boostPads){
      const c = getCenterFloat(pad.index);
      const pos = playerWorldPos();
      const d = Math.hypot(pos.x - c.x, pos.y - c.y);
      if(d < 48 && player.onGround && !pad.used){ // allow reuse after small cooldown
        player.speed = Math.min(player.speed + CONFIG.boostPad.power, CONFIG.car.maxSpeed * 1.8);
        pad.used = true;
        setTimeout(()=> pad.used = false, 900); // prevent immediate re-trigger
        flashMsg('Boost Pad!', '#8be9ff', 650);
        for(let i=0;i<14;i++) spawnParticle(pos.x + (Math.random()-0.5)*40, pos.y + (Math.random()-0.5)*18, (Math.random()-0.5)*120, (Math.random()-0.5)*40, 0.7 + Math.random()*0.4, '#8be9ff', 3);
      }
    }

    // Item box pickup
    for(const ib of itemBoxes){
      if(!ib.taken){
        const c = getCenterFloat(ib.index);
        const pos = playerWorldPos();
        const d = Math.hypot(pos.x - c.x, pos.y - c.y);
        if(d < CONFIG.itemBoxes.spawnRadius){
          // give a random item to player
          giveRandomItem(player);
          ib.taken = true;
          setTimeout(()=> ib.taken = false, 9000); // respawn after 9s
          flashMsg('Item Box!', '#f97316', 700);
        }
      }
    }

    // banana collision checks: if player or AI hits banana -> spin out (reduce speed)
    for(let i=droppedBananas.length-1;i>=0;i--){
      const b = droppedBananas[i];
      // player collision
      const pw = playerWorldPos();
      if(Math.hypot(pw.x - b.x, pw.y - b.y) < b.radius + 8){
        player.speed = player.speed * 0.45;
        droppedBananas.splice(i,1);
        flashMsg('Banana! You spun out', '#f59e0b', 800);
        continue;
      }
      // AI collision
      for(const a of ais){
        const aw = aiWorldPos(a);
        if(Math.hypot(aw.x - b.x, aw.y - b.y) < b.radius + 8){
          a.speed = a.speed * 0.55;
          droppedBananas.splice(i,1);
          break;
        }
      }
      // reduce life
      b.life -= dt;
      if(b.life <= 0) { droppedBananas.splice(i,1); }
    }

    // AI logic: simple centerline follower with speed target and small randomness + item usage
    for(const a of ais){
      // move forward
      const tlen = tangentLengthAt(a.index);
      const idxDelta = (a.speed * dt) / tlen;
      const prev = a.index;
      a.index = wrapIndex(a.index + idxDelta);

      // small steering logic: if upcoming corner, slow a bit
      // sample future tangent curvature approx by comparing directions a bit ahead
      const cur = getCenterFloat(a.index);
      const a2 = getCenterFloat(a.index + 4);
      const dir1 = Math.atan2(a2.y - cur.y, a2.x - cur.x);
      // align heading by setting lateral towards 0 slowly
      a.lateral = lerp(a.lateral, 0, clamp(1.5 * dt,0,1));
      // maintain speed target with variation
      const targetSpeed = CONFIG.car.maxSpeed * (0.65 + 0.15 * Math.sin(a.index*0.02 + a.color.length));
      a.speed = lerp(a.speed, targetSpeed, clamp(0.8 * dt,0,1));
      // if item box ahead and no item, occasionally take it (simplified)
      if(!a.hasItem && Math.random() < 0.0009) giveRandomItem(a);
      // use item randomly if behind player
      if(a.hasItem && Math.random() < 0.0015){
        // if shell: target player
        if(a.hasItem === 'shell'){
          player.speed = Math.max(80, player.speed - 260);
          a.hasItem = null;
        } else if(a.hasItem === 'mushroom'){
          a.speed = Math.min(a.speed + 260, CONFIG.car.maxSpeed * 1.6);
          a.hasItem = null;
        }
      }
    }

    // lap detection crossing sfIndex
    if(runActive){
      const prevWrapped = wrapIndex(prevIndex);
      const curWrapped = wrapIndex(player.index);
      if(crossesIndex(prevWrapped, curWrapped, sfIndex)){
        const nowMs = now();
        const lapSec = (nowMs - lapStartTime) / 1000;
        lapTimes.push(lapSec);
        lapStartTime = nowMs;
        lapCounterEl.textContent = `${lapTimes.length} / ${CONFIG.laps}`;
        if(lapTimes.length >= CONFIG.laps){
          // finish run
          runActive = false;
          startBtn.textContent = 'Start Run';
          const total = lapTimes.reduce((a,b)=>a+b,0);
          totalTimeEl.textContent = fmtTime(total);
          if(!bestRecord || total < bestRecord.total){
            bestRecord = { total, date: new Date().toISOString() };
            try{ localStorage.setItem('coconut_best_3p_v2', JSON.stringify(bestRecord)); }catch(e){}
            bestTimeEl.textContent = fmtTime(bestRecord.total);
            flashMsg('New Personal Best!', '#16a34a', 1200);
          }
        } else flashMsg(`Lap ${lapTimes.length}`, '#f97316', 650);
      }
    }

    // update particles
    updateParticles(dt);

    // camera follow: behind player world pos along angle
    const pwp = playerWorldPos();
    const camTargetX = pwp.x - Math.cos(player.angle) * 160;
    const camTargetY = pwp.y - Math.sin(player.angle) * 120 - Math.max(0, player.altitude) * 0.3;
    camera.x = lerp(camera.x, camTargetX, clamp(6*dt,0,1));
    camera.y = lerp(camera.y, camTargetY, clamp(6*dt,0,1));
    camera.zoom = lerp(camera.zoom, 1.03 - 0.12 * clamp(Math.abs(player.speed)/CONFIG.car.maxSpeed,0,1), clamp(2*dt,0,1));

    // render
    render();

    requestAnimationFrame(update);
  }

  function crossesIndex(a,b,target){
    // works with wrapped modular indices 0..L
    const L = centerline.length;
    // normalize into [0, L)
    a = ((a%L)+L)%L; b = ((b%L)+L)%L; target = ((target%L)+L)%L;
    if(a < b) return (a < target && target <= b);
    // wrapped around
    return (a < target && target < L) || (0 <= target && target <= b);
  }

  // update mini-turbo UI
  function updateMTUI(){
    const maxCharge = CONFIG.car.miniTurboLevels * 1.6;
    const pct = clamp(player.driftCharge / maxCharge, 0, 1);
    mtFill.style.width = `${Math.round(pct*100)}%`;
    // decide label
    let label = 'No Charge', color = '#999';
    if(player.driftCharge >= 2.2){ label = 'Purple'; color = CONFIG.car.miniTurbo[2].color; }
    else if(player.driftCharge >= 1.2){ label = 'Orange'; color = CONFIG.car.miniTurbo[1].color; }
    else if(player.driftCharge >= 0.5){ label = 'Blue'; color = CONFIG.car.miniTurbo[0].color; }
    mtLabel.textContent = label;
    mtFill.style.background = label === 'No Charge' ? 'linear-gradient(90deg,#ddd,#bbb)' : `linear-gradient(90deg, ${color}, #ffffff33)`;
  }

  // -----------------------
  // Rendering with camera transform (3rd person behind view)
  // We translate canvas origin to center, then rotate world by -player.angle so the track rotates,
  // and draw the world. The player car is drawn at a fixed screen position (slightly lower than center),
  // giving the behind-the-car perspective feeling.
  // -----------------------
  function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // background sky/sea
    const grd = ctx.createLinearGradient(0,0,0,canvas.height);
    grd.addColorStop(0,'#eaf6ff'); grd.addColorStop(0.5,'#fff6ea'); grd.addColorStop(1,'#fffdf6');
    ctx.fillStyle = grd; ctx.fillRect(0,0,canvas.width,canvas.height);

    // Save and apply camera transform: move center to canvas center, then translate by -camera, then rotate so player's forward is up screen
    ctx.save();
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.rotate(-player.angle);
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-camera.x, -camera.y);

    // draw distant ocean (static)
    ctx.save();
    ctx.fillStyle = '#96e0ff';
    ctx.beginPath();
    ctx.ellipse(centerX+480, centerY-320, 540, 260, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // draw track surface (left to right polygons)
    ctx.save();
    ctx.beginPath();
    for(let i=0;i<track.length;i++){
      const p = track[i];
      ctx.lineTo(p.leftX, p.leftY);
    }
    for(let i=track.length-1;i>=0;i--){
      const p = track[i];
      ctx.lineTo(p.rightX, p.rightY);
    }
    ctx.closePath();
    ctx.fillStyle = '#f3dca5';
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#d9c497';
    ctx.stroke();
    ctx.restore();

    // draw boost pads
    for(const pad of boostPads){
      const cp = centerline[pad.index % centerline.length];
      ctx.save();
      ctx.translate(cp.x, cp.y);
      ctx.rotate(player.angle); // consistent orientation in world
      ctx.fillStyle = '#8be9ff';
      roundRect(ctx, -24, -8, 48, 16, 6, true, true);
      ctx.restore();
    }

    // draw ramp
    {
      const r = centerline[rampIndex];
      ctx.save();
      ctx.translate(r.x, r.y);
      ctx.fillStyle = '#d1a26b';
      ctx.beginPath(); ctx.ellipse(0,0,86,22,0,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // draw item boxes
    for(const ib of itemBoxes){
      const c = centerline[ib.index];
      ctx.save();
      ctx.translate(c.x, c.y);
      ctx.fillStyle = '#fff';
      roundRect(ctx, -16, -14, 32, 28, 6, true, true);
      ctx.fillStyle = '#f97316';
      ctx.fillRect(-6, -4, 12, 8);
      ctx.restore();
    }

    // draw dropped bananas
    for(const b of droppedBananas){
      ctx.save(); ctx.translate(b.x, b.y); ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.ellipse(0,0,8,6,0,0,Math.PI*2); ctx.fill(); ctx.restore();
    }

    // draw centerline (ghost)
    ctx.save();
    ctx.beginPath();
    for(let i=0;i<centerline.length;i++){
      const p = centerline[i];
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.closePath();
    ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1; ctx.stroke();
    ctx.restore();

    // draw AI racers
    for(const a of ais){
      const pos = aiWorldPos(a);
      ctx.save();
      ctx.translate(pos.x, pos.y - 2);
      ctx.rotate(a.index ? Math.atan2(centerline[Math.floor(a.index+1)%centerline.length].y - centerline[Math.floor(a.index)%centerline.length].y, centerline[Math.floor(a.index+1)%centerline.length].x - centerline[Math.floor(a.index)%centerline.length].x) : 0);
      // shadow
      ctx.beginPath(); ctx.ellipse(0, 8, 16, 7, 0, 0, Math.PI*2); ctx.fillStyle = 'rgba(0,0,0,0.16)'; ctx.fill();
      // body
      ctx.fillStyle = a.color; roundRect(ctx, -20, -12, 40, 24, 6, true, true);
      ctx.restore();
    }

    // draw player car at its world position (with altitude)
    const ppos = playerWorldPos();
    ctx.save();
    ctx.translate(ppos.x, ppos.y - Math.max(0, player.altitude*0.35));
    ctx.rotate(player.angle);
    // shadow
    ctx.beginPath(); ctx.ellipse(0, 12, 20 + Math.min(30, Math.abs(player.speed)/10), 8, 0, 0, Math.PI*2); ctx.fillStyle = 'rgba(0,0,0,0.18)'; ctx.fill();
    // car body
    ctx.fillStyle = '#ef4444';
    roundRect(ctx, -26, -14, 52, 28, 6, true, true);
    ctx.fillStyle = 'rgba(255,255,255,0.6)'; roundRect(ctx, -12, -10, 24, 12, 3, true, false);
    // small exhaust if boosting
    if(now() < mtState.activeUntil || player.speed > CONFIG.car.maxSpeed * 1.05){
      ctx.fillStyle = 'rgba(255,220,120,0.9)';
      ctx.fillRect(-34, 0, 6, 6);
    }
    ctx.restore();

    // restore camera transform
    ctx.restore();

    // draw HUD / UI elements in screen space
    // mini-turbo bar already updated via DOM

    // draw particles in screen space (convert world to screen)
    for(const p of particles){
      const s = worldToScreen(p.x, p.y, 0);
      ctx.beginPath();
      ctx.fillStyle = p.color;
      ctx.globalAlpha = clamp(1 - p.age / p.life, 0, 1);
      ctx.arc(s.x, s.y, p.size * (camera.zoom*0.9), 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // draw center cross where player's forward is (for orientation)
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    ctx.fillRect(canvas.width/2 - 2, canvas.height/2 - 2, 4, 4);
    ctx.restore();

    // draw dropped bananas in screen coords small overlay (already in world draw)
    // draw item box text
    if(player.hasItem){
      itemBoxEl.textContent = player.hasItem[0].toUpperCase();
    }

    // draw timer text
    ctx.save();
    ctx.fillStyle = '#000000cc';
    ctx.font = '14px Inter, Arial';
    ctx.fillText(`Speed: ${Math.round(player.speed)}`, 12, 22);
    ctx.restore();
  }

  // extend roundRect to context if not present
  CanvasRenderingContext2D.prototype.roundRect = CanvasRenderingContext2D.prototype.roundRect || function(x,y,w,h,r){
    if(r === undefined) r = 6;
    this.beginPath();
    this.moveTo(x + r, y);
    this.arcTo(x + w, y, x + w, y + h, r);
    this.arcTo(x + w, y + h, x, y + h, r);
    this.arcTo(x, y + h, x, y, r);
    this.arcTo(x, y, x + w, y, r);
    this.closePath();
    return this;
  };

  // -----------------------
  // Start/reset handlers
  // -----------------------
  startBtn.addEventListener('click', ()=>{
    if(!runActive){
      runActive = true;
      lapStartTime = now();
      lapTimes = [];
      startBtn.textContent = 'Running...';
      lapCounterEl.textContent = `0 / ${CONFIG.laps}`;
      curLapTimeEl.textContent = fmtTime(0);
      totalTimeEl.textContent = fmtTime(0);
    }
  });
  resetBtn.addEventListener('click', ()=>{
    // place at start
    player.index = sfIndex + 1;
    player.lateral = 0;
    player.speed = 0;
    // face along tangent
    const st = getCenterFloat(player.index);
    const st2 = getCenterFloat(player.index + 1);
    player.angle = Math.atan2(st2.y - st.y, st2.x - st.x);
    player.altitude = 0;
    player.yVel = 0;
    player.onGround = true;
    player.drifting = false;
    player.driftCharge = 0;
    runActive = false;
    startBtn.textContent = 'Start Run';
    lapTimes = [];
    lapCounterEl.textContent = `0 / ${CONFIG.laps}`;
    curLapTimeEl.textContent = fmtTime(0);
    totalTimeEl.textContent = fmtTime(0);
  });
  clearBestBtn.addEventListener('click', ()=>{
    try{ localStorage.removeItem('coconut_best_3p_v2'); }catch(e){}
    bestRecord = null;
    bestTimeEl.textContent = '--:--.---';
    flashMsg('Cleared best', '#6b7280', 700);
  });

  // item use binding Q (edge detection)
  let prevKeys = { q:false };
  window.addEventListener('keydown', (e)=> {
    if(e.key.toLowerCase() === 'q' && !prevKeys.q) { usePlayerItem(); prevKeys.q = true; }
  });
  window.addEventListener('keyup', (e)=> { if(e.key.toLowerCase() === 'q') prevKeys.q = false; });

  // -----------------------
  // Run loop
  // -----------------------
  requestAnimationFrame(update);

  // -----------------------
  // Give keyboard shortcuts for debugging & tuning
  // -----------------------
  window.addEventListener('keydown', (e)=>{
    if(e.key === '1') { player.speed += 140; flashMsg('Debug boost +', '#8be9ff', 400); }
    if(e.key === '2') { giveRandomItem(player); flashMsg('Debug item', '#f97316', 400); }
  });

  // -----------------------
  // Utilities used earlier
  // -----------------------
  function spawnParticle(x,y,vx,vy,life,color,size=3){ particles.push({x,y,vx,vy,life,age:0,color,size}); }
  function giveRandomItem(target){
    const it = ITEM_POOL[Math.floor(Math.random()*ITEM_POOL.length)];
    target.hasItem = it;
    if(target === player) itemBoxEl.textContent = it[0].toUpperCase();
  }
  function usePlayerItem(){ /* implemented above (duplicated for closure safety) */ }
  // we defined usePlayerItem earlier, but ensure function reference exists here:
  // (no-op placeholder, real implementation is above)
  // -----------------------

  // small initial placement
  (function initPosition(){
    player.index = sfIndex + 1;
    const st = getCenterFloat(player.index);
    const st2 = getCenterFloat(player.index + 1);
    player.angle = Math.atan2(st2.y - st.y, st2.x - st.x);
  })();

  // expose some globals for debugging
  window._CK = { player, ais, centerline, track, spawnParticle };

})(); // end closure
</script>
</body>
</html>
